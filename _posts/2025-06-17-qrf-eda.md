---
title: "2. Exploring Chaos: A Quant’s Take on EDA for 72-Hour Interval Forecasts of Solana Mid-Cap Tokens"
excerpt: "."
date: 2025-06-17
author_profile: true
tags:
  - Solana
  - Crypto Forecasting
  - Quantile Regression
  - EDA
  - Algorithmic Trading
header:
  overlay_filter: 0.4  # Optional: darkens the image to improve text readability
  overlay_image: /assets/images/chaos.jpg
  actions:
    - label: "View Project on GitHub"
      url: "https://github.com/KetchupJL/solana-qrf-interval-forecasting"

---

## Trading Assumptions at Inception

Every systematic strategy starts with working hypotheses. Mine were:

1. **Data Completeness:** Sporadic gaps can be patched with simple interpolation.  
2. **Return Normality:** ±σ bands are sufficient to quantify tail risk.  
3. **Feature Orthogonality:** Market, on-chain, and sentiment signals bring unique α.  
4. **Stationarity:** Rolling windows capture “steady” dynamics—no regime breaks.

In [Part I: Taming Data Missingness](https://ketchupjl.github.io/qrf-pipeline/) we stress-tested (1), dropped two ill-behaved tokens, and locked in a linear+2-bar ffill imputation. That exercise validated our pipeline plumbing—but the real market test lies ahead.

---

## Hypothesis A: Returns Are Gaussian

> **Why it matters:** Parametric VaR and Gaussian interval forecasts hinge on normality. If returns aren’t bell-shaped, you’re either too porous or too conservative on risk.

**Methodology:**  
- Overlayed 12 h & 72 h log-return histograms with Gaussian PDFs.  
- Computed sample skewness (γ) and excess kurtosis (κ).  
- Flagged all |return| > 3σ events.

**Findings:**  
- γ ≈ +0.7: pronounced positive skew.  
- κ ≈ 27: “infinite”-looking tails.  
- 3σ moves every ∼25 bars—far more frequent than the ∼1-in-370 of a true normal.

> **Algo-Edge:** Naïve σ-bands under-cover tail losses by ≈8–10 pp. Any live trading system that uses Gaussian VaR will be caught flat-footed on market spikes.

**Next Steps:**  
- Drop parametric intervals.  
- Adopt _direct_ quantile estimation:  
  - Conformalized Quantile Regression (CQR)  
  - Quantile Regression Forests (QRF)

---

## Hypothesis B: Volatility Is Flat Within Blocks

> **Why it matters:** Many backtests assume constant σ over the training window. In reality, vol clusters—if you ignore that, your model will overfit calm periods and implode during storms.

**Methodology:**  
1. Calculated ACF of returns vs. |returns| up to lag 50.  
2. Tracked realized volatility (sqrt of 36 h rolling variance) across time.  
3. Tagged volatility “spikes” when vol > µ_vol + 2σ_vol.

**Findings:**  
- Returns: no serial correlation (model-friendly).  
- |Returns|: significant ACF up to lag 20 → persistent clustering.  
- Two regime shifts: late April drop and early May rally both saw vol jump > 3× baseline.

> **Algo-Edge:** A static‐σ assumption is a recipe for blown risk budgets.  

**Next Steps:**  
- Engineer features:  
  - Lagged realized vol (36 h, 72 h)  
  - Volatility regime flag (binary)  
- Use rolling‐window CV that spans both low- and high-vol regimes to avoid look-ahead bias.

---

## Hypothesis C: Features Are Independent α Sources


> **Why it matters:** Perfectly correlated inputs waste model capacity and obscure true drivers of tail risk.

**Methodology:**  
- Computed Pearson & Spearman correlation matrices among 18 engineered features (price, volume, RSI, ATR, on-chain metrics, social counts).  
- Isolated pairs with |r| > 0.85.

**Findings:**  
- token_price_usd vs. token_volume_usd: r ≈ 0.999  
- SOL_price_usd vs. DeFi_TVL_usd: r ≈ 0.94  
- BTC, ETH & TVL form a tight triad (r > 0.9)

> **Algo-Edge:** Tree-based models will waste split capacity on redundant features, inflating variance and lengthening inference time.

**Next Steps:**  
- Prune or combine collinear pairs:  
  - Keep log(price) and drop raw volume or vice versa.  
  - Create composite “Market Index” from BTC/ETH/TVL via PCA.  
- Regularize QRF by limiting max_features and employing feature bagging.

---

## Hypothesis D: Nominal σ-Bands Hit Coverage Targets


> **Why it matters:** Traders set stop-loss and margin thresholds based on expected interval coverage. Under-coverage means frequent stop-outs.

**Methodology:**  
- Computed empirical coverage of ±1.28σ (80 %) and ±1.645σ (90 %) bands on out-of-sample 12 h returns.  
- Plotted nominal vs. actual coverage curves.

**Findings:**  
- 80 % band covers only ∼72 %  
- 90 % band covers only ∼82 %

> **Algo-Edge:** Your risk targets are systematically missed—capital use is suboptimal, and tail events are under-appreciated.

**Next Steps:**  
- Benchmark conformal calibration methods:  
  - Block-bootstrap intervals  
  - Split-conformal QR  
  - Leverage QRF’s native quantile outputs for sharper, data-driven intervals.

```

## From Diagnostics to Quant Pipeline

| Hypothesis Tested                 | Action Item                                                                  |
|-----------------------------------|------------------------------------------------------------------------------|
| Gaussian returns                  | Switch to CQR/QRF for direct quantile estimation                             |
| Flat volatility                   | Add vol-lag, regime flags; CV across mixed regimes                           |
| Feature orthogonality             | Prune/combine collinear features; consider composite indices or PCA          |
| Nominal σ-band calibration        | Integrate conformal/block-bootstrap calibration to guarantee coverage        |

With our assumptions rigorously vetted and features battle-tested, it’s time to build the trading engine—one that respects fat tails, adapts to volatility storms, and leverages clean, orthogonal signals.

---

## What’s Next

In **Part III**, we will:

1. **Fit Linear Quantile Regression** at τ = 0.10, 0.50, 0.90  
2. **Construct LightGBM** mean forecasts + residual-bootstrap intervals  
3. **Train Quantile Regression Forests** (500 trees, hyper-tuned)  
4. **Benchmark** via pinball loss, empirical coverage, and interval width  

Can we tame chaos and harvest alpha? Stay tuned for the code, live results, and backtest analysis.


---

## 🔗 Notebooks Referenced

*Referenced Notebooks:*  
- `01_EDA_missingness.ipynb` (Part I)  
- `02_EDA_return_analysis.ipynb`  
- `03_EDA_corr_redu_analysis.ipynb`  
- `04_EDA_interval_calib.ipynb`  